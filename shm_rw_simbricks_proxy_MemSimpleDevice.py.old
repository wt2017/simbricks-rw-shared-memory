#!/usr/bin/env python3
"""
Direct Memory Connection SimBricks experiment script

This script implements a direct memory connection approach that works with Gem5Sim's expectations
while providing external memory access through SimBricks.

System architecture:
Application(x86) --> gem5 x86 CPU --> Memory Proxy --> MemInterconnect --> External memory
"""

from simbricks.orchestration import system
from simbricks.orchestration import simulation as sim
from simbricks.orchestration import instantiation as inst
from simbricks.orchestration.helpers import instantiation as inst_helpers
from simbricks.orchestration.system import mem as sys_mem
from simbricks.orchestration.system import host as sys_host
from simbricks.orchestration.system import disk_images

# Create empty instantiations list that simbricks-run expects
instantiations = []

print("Creating direct memory connection experiment...")
print("System architecture: Application(x86) --> gem5 x86 CPU --> Memory Proxy --> MemInterconnect --> External memory")
print(f"Shared memory address: 0x80000000")
print(f"Shared memory size: 4MB")
print("Expected output: [shared_bmk] PASS: all 1024 bytes match")

# Create system
sys = system.System()

# Create x86 host
host = sys_host.LinuxHost(sys)
host.name = "x86_host"
host.memory = 1024  # 1GB memory
host.cores = 1
host.cpu_freq = "3GHz"

host.add_disk(system.DistroDiskImage(sys, name="shm-rw"))
host.add_disk(system.LinuxConfigDiskImage(sys, host))

# Create external memory device
external_mem = sys_mem.MemSimpleDevice(sys)
external_mem.name = "external_mem"
external_mem._addr = 0x80000000  # Physical address used by shm_rw - moved to avoid overlap with main memory
external_mem._size = 4 * 1024 * 1024  # 4MB
external_mem._as_id = 0

# Create the memory proxy component with the same memory region as external memory
mem_proxy = sys_mem.MemHostInterface(host)
mem_proxy.name = "memory_proxy"
mem_proxy._addr = 0x80000000
mem_proxy._size = 4 * 1024 * 1024
mem_proxy._as_id = 0

# Create memory interconnect to bridge proxy and external memory
mem_interconnect = sys_mem.MemInterconnect(sys)
mem_interconnect.name = "mem_interconnect"

# Connect the interconnect to the external memory device
interconnect_channel = mem_interconnect.connect_device(external_mem._mem_if)

# Connect the memory proxy to the interconnect using its existing _mem_if
# The connect_device method will handle the interface connection properly
proxy_channel = mem_interconnect.connect_host(mem_proxy)

# Add memory route for the external memory device
interconnect_host_if = None
for intf in mem_interconnect.interfaces():
    if isinstance(intf, sys_mem.MemHostInterface):
        interconnect_host_if = intf
        break

if interconnect_host_if:
    mem_interconnect.add_route(
        dev=interconnect_host_if,
        vaddr=0x80000000,
        len=4 * 1024 * 1024,
        paddr=0x80000000
    )

print(f"Direct external memory connection created")
print(f"External memory device: addr=0x{external_mem._addr:x}, size={external_mem._size} bytes")
print(f"Memory proxy will bridge CPU accesses to external memory")

# Configure application
shm_rw_app = sys_host.app.GenericRawCommandApplication(host, [
    "/home/ubuntu/shm_rw_fixed_addr"  # Use syscall-based version instead of /dev/mem version
])
host.add_app(shm_rw_app)

# Create simulation configuration
simulation = sim.Simulation("shm_rw_simbricks_proxy_MemSimpleDevice", sys)
simulation.timeout = 600
simulation.verbose = True

# Configure component mapping
host_sim = sim.Gem5Sim(simulation)
host_sim.name = "x86_host_sim"
host_sim.wait_terminate = True
host_sim.add(host)

# Add the memory proxy to the same simulator as the host
# This way, Gem5Sim will process the proxy's MemHostInterface but the host remains clean
host_sim.add(mem_proxy)

# Create BasicInterconnect simulator for the memory interconnect
interconnect_sim = sim.BasicInterconnect(simulation)
interconnect_sim.name = "mem_interconnect_sim"
interconnect_sim.wait_terminate = True
interconnect_sim.add(mem_interconnect)

# Create BasicMem simulator for the external memory device
mem_sim = sim.BasicMem(simulation)
mem_sim.name = "external_mem_sim"
mem_sim.wait_terminate = True
mem_sim.add(external_mem)

# Create instantiation
instantiation = inst_helpers.simple_instantiation(simulation)
fragment = inst.Fragment()
fragment.add_simulators(host_sim, interconnect_sim, mem_sim)
instantiation.fragments = [fragment]

# Add to instantiations list
instantiations.append(instantiation)

print(f"Direct memory connection experiment created successfully, containing {len(instantiations)} instantiations")
print("This approach should work with Gem5Sim's expectations while providing external memory access")
